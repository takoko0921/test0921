//******************************************************************************
//
//
//      BGクラス
//
//
//******************************************************************************

//------< インクルード >---------------------------------------------------------
#include "all.h"

//------< using >---------------------------------------------------------------
using namespace GameLib;

//------< データ >--------------------------------------------------------------
char st0_terrain[BG::CHIP_NUM_Y][BG::CHIP_NUM_X] = {
	13,13,13,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3							,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3	,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,4,4,4,4,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,3		,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3

};

char st1_terrain[BG::CHIP_NUM_Y][BG::CHIP_NUM_X] = {
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3									,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,2,-1,-1,-1,-1,3,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,3,3,3,3,3,3,3,3,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3				,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,-1,-1,-1,-1,3			,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,4,4,4,4,3			,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,-1,-1,-1,-1,-1,-1,4,4,4,3,3,3,3,3,3,3					,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,4,3,3,3,3,3,3,3,3,3,3					,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3					,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3						,
3,-1,-1,-1,-1,-1,-1,-1,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3							,
3,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3							,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3


};

char st2_terrain[BG::CHIP_NUM_Y][BG::CHIP_NUM_X] = {
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3									   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,3,3,3,3,3,3,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3			   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,-1,-1,-1,-1,3						   ,
3,4,4,4,4,4,4,4,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3				   ,
3,3,3,3,3,3,3,3,3,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3				   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3		   ,
3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,3,3,3			   ,
3,-1,-1,-1,-1,-1,-1,3,3,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,3,3,3				   ,
3,-1,-1,-1,-1,-1,-1,3,3,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,3,3,3,3,3,3				   ,
3,-1,-1,-1,-1,-1,-1,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3							   ,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3


};



//----------------------------------------------------------------------
//  コンストラクタ
//----------------------------------------------------------------------
BG::BG() : scroll(VECTOR2(0, 0)), back(), terrain()
{
}

//----------------------------------------------------------------------
//  デストラクタ
//----------------------------------------------------------------------
BG::~BG()
{

}

//----------------------------------------------------------------------
//  初期設定
//----------------------------------------------------------------------
void BG::init()
{
	// BG用データのクリア
	clear();


	//空のterrainのデータが入らないようにする
	if (!loadMapData(st1_terrain, terrain))
	{
		assert(!"地形データのロードに失敗");
	}
	
	{
		switch (Game::instance()->stage) {
		case 0:
			if (!loadMapData(st0_terrain, terrain))
			{
				assert(!"地形データのロードに失敗");
			}
			break;
		case 1:
			if (!loadMapData(st1_terrain, terrain))
			{
				assert(!"地形データのロードに失敗");
			}
			break;
		case 2:
			if (!loadMapData(st2_terrain, terrain))
			{
				assert(!"地形データのロードに失敗");
			}
			break;/*
		case 3:
			if (!loadMapData(st1_terrain, terrain))
			{
				assert(!"地形データのロードに失敗");
			}
			break;*/
		case 3:
			if (!loadMapData(st1_terrain, terrain))
			{
				assert(!"地形データのロードに失敗");
			}
			Game::instance()->changeScene(Title::instance());   // タイトルシーンに切り替える

			//Game::instance()->stage = 1;
			break;

		}
	}
	
}

//----------------------------------------------------------------------
//  メンバ変数のクリア
//----------------------------------------------------------------------
void BG::clear()
{
	SecureZeroMemory(terrain, sizeof(terrain)); // 地形
	SecureZeroMemory(back, sizeof(back));       // 背景

	scroll = {};                                // スクロール座標（画面左上の位置のワールド座標）
}

//----------------------------------------------------------------------
//  マップデータのロード（仮）
//----------------------------------------------------------------------
bool BG::loadMapData(const char data[CHIP_NUM_Y][CHIP_NUM_X], char map[CHIP_NUM_Y][CHIP_NUM_X])
{
	for (int y = 0; y < BG::CHIP_NUM_Y; y++)
	{
		for (int x = 0; x < BG::CHIP_NUM_X; x++)
		{
			map[y][x] = data[y][x];
		}
	}

	return true;
}

//----------------------------------------------------------------------
//  更新処理
//----------------------------------------------------------------------
void BG::update()
{
}

//----------------------------------------------------------------------
//  マップのスクロール
//----------------------------------------------------------------------
void BG::scrollMap()
{

}

//----------------------------------------------------------------------
//  背景描画
//----------------------------------------------------------------------
void BG::drawBack()
{
	using namespace system;
	sprBack.draw(
		SCREEN_WIDTH / 2,
		SCREEN_HEIGHT / 2,
		20, 20
	);
}

//----------------------------------------------------------------------
//  地形描画
//----------------------------------------------------------------------
void BG::drawTerrain()
{
	draw(TEXNO::MAP_TERRAIN, terrain);
}

//----------------------------------------------------------------------
//  BGデータ描画
//----------------------------------------------------------------------
void BG::draw(int texNo, char map[CHIP_NUM_Y][CHIP_NUM_X])
{
	const int DIV_X = static_cast<int>(scroll.x) / CHIP_SIZE; // division x
	const int DIV_Y = static_cast<int>(scroll.y) / CHIP_SIZE; // division y
	const int REM_X = static_cast<int>(scroll.x) % CHIP_SIZE; // remainder x
	const int REM_Y = static_cast<int>(scroll.y) % CHIP_SIZE; // remainder y

	texture::begin(texNo);
	for (int y = 0; y < system::SCREEN_HEIGHT / CHIP_SIZE + 1; y++)
	{
		for (int x = 0; x < system::SCREEN_WIDTH / CHIP_SIZE + 1; x++)
		{
			if (DIV_X + x >= CHIP_NUM_X || DIV_Y + y >= CHIP_NUM_Y)
				continue; // 添え字の範囲チェック

			char chip = map[DIV_Y + y][DIV_X + x];
			if (-1 == chip) continue;

			texture::draw(texNo,
				static_cast<float>(x * CHIP_SIZE - REM_X),
				static_cast<float>(y * CHIP_SIZE - REM_Y),
				1, 1,
				static_cast<float>(chip % CHIP_NUM_PER_LINE * CHIP_SIZE),
				static_cast<float>(chip / CHIP_NUM_PER_LINE * CHIP_SIZE),
				static_cast<float>(CHIP_SIZE), static_cast<float>(CHIP_SIZE)
			);
		}
	}
	texture::end(texNo);
}

//******************************************************************************
//
//      あたり判定
//
//******************************************************************************

//----------------------------------------------------------------------
//  指定した座標のマップチップの種類を取得する
//----------------------------------------------------------------------
int BG::getData(char map[CHIP_NUM_Y][CHIP_NUM_X], float x, float y)
{
	int divX = static_cast<int>(x) / 32;      // x方向のインデックス
	int divY = static_cast<int>(y) / 32;      // y方向のインデックス
	return map[divY][divX];
}

//----------------------------------------------------------------------
//  指定した座標の地形の属性を取得する
//----------------------------------------------------------------------
BG::TR_ATTR BG::getTerrainAttr(float x, float y)
{
	// インデックス取得
	int index = getData(terrain, x, y);

	// インデックスが-1であればTR_NONEを返す
	if (index < 0) return TR_NONE;

	// x方向のインデックス
	int remX = index % CHIP_NUM_PER_LINE;

	// y方向のインデックス
	int divY = index / CHIP_NUM_PER_LINE;

	// 添字の範囲チェック
	assert(remX >= 0 && remX < CHIP_NUM_PER_LINE);
	assert(divY >= 0 && divY < CHIP_LINE_NUM);

	// リターン
	return terrainAttr[divY][remX];
}

//----------------------------------------------------------------------
//  指定したy座標が、マップチップの上側4分の1にあるかどうかを返す
//----------------------------------------------------------------------
bool BG::isUpperQuater(float y)
{
	return static_cast<int>(y) % CHIP_SIZE < CHIP_SIZE / 4;
}

//----------------------------------------------------------------------
//  下方向に向けて、指定した座標が壁であるかどうか
//----------------------------------------------------------------------
bool BG::isHitDown(float x, float y)
{
	switch (getTerrainAttr(x, y))                           // 地形の属性を取得する
	{
	case TR_ATTR::ALL_BLOCK:    return true;                // 全て壁の地形であった
	case TR_ATTR::UPPER_BLOCK:  return isUpperQuater(y);    // 上側４分の１が地形で、上４分の１に含まれるか
	case TR_ATTR::NEEDLE:    return false;
	}
	return false;                                           // 地形ではなかった場合
}

bool BG::isHitAll(float x, float y)
{
	switch (getTerrainAttr(x, y)) {
	case TR_ATTR::ALL_BLOCK:    return true;
	case TR_ATTR::NEEDLE:    return false;
	default:return false;
	}
}

//----------------------------------------------------------------------
//  床方向へのあたり判定
//----------------------------------------------------------------------
bool BG::isFloor(float x, float y, float width)
{
	for (; width > 0; width -= CHIP_SIZE)       // widthをCHIP_SIZE分減らしていく
	{
		const float left = x - width;
		const float right = x + width;

		// エリアチェック
		if (left < 0)       continue;
		if (right >= WIDTH) continue;

		if (isHitDown(left, y))  return true;   // 左端から
		if (isHitDown(right, y)) return true;   // 右端から
	}
	return isHitDown(x, y);                     // 最後に真ん中で判定
}

//----------------------------------------------------------------------
//  下方向にあたっている場合の補正処理
//----------------------------------------------------------------------
void BG::mapHoseiDown(OBJ2D* obj)
{
	float y = obj->position.y;                          // わかりやすく書くためいったんyに代入
	int intY = static_cast<int>(y);
	y = static_cast<float>(intY - intY % CHIP_SIZE);
	obj->position.y = y - ADJUST_Y;                     // 少し浮かせる
	obj->speed.y = (std::min)(obj->speed.y, 0.0f);      // 地面にあたったので速度が止まる
}

#if 2
//******************************************************************************
// TODO:02 天井にあたっているか
//------------------------------------------------------------------------------
/*
課題）
	地面判定の isFloor 関数と同じような形で天井の判定を行う。
	下から上にすり抜けられる壁が存在し（逆は存在しない）、その場合あたり判定処理は発生
	しないため、天井判定では地面判定で使用したisHitDownとは別の isHitAll 関数を使う。
	BG::isFloor 関数を参考に、isHitDown の部分をisHitAllに書き換え作成しなさい
*/
//******************************************************************************
#endif
bool BG::isCeiling(float x, float y, float width)
{
	//TODO_02
	for (; width > 0; width - CHIP_SIZE) {
		const float left = x - width;
		const float right = x + width;

		// エリアチェック
		if (left < 0)       continue;
		if (right >= WIDTH) continue;

		if (isHitAll(left, y))  return true;
		if (isHitAll(right, y)) return true;
		return (isHitAll(x, y));
	}
}

#if 4
//******************************************************************************
// TODO:04 上方向補正処理
//------------------------------------------------------------------------------
/*
説明）
	上方向にめり込んでいる場合、y方向の位置を補正する
	BG::mapHoseiDown を参考に作成せよ
手順）
	□ float y を宣言し、（プレイヤーの位置yからプレイヤーのサイズyを引いた値）を保持
	□ y に天井にめり込んでいる分の数値を足す（プリントかpdf参照）
	□ プレイヤーの位置yに（yにプレイヤーのサイズyを足した値）を代入する
	□ プレイヤーの速度yが負であれば、プレイヤーの速度yに0.0fを代入する
*/
//******************************************************************************
#endif
void BG::mapHoseiUp(OBJ2D* obj)
{
	float y = obj->position.y - obj->size.y;
	int intY = static_cast<int>(y);
	y = static_cast<float>(intY + intY % CHIP_SIZE);
	obj->speed.y = (std::max)(obj->speed.y, 0.0f);
	//obj->speed.y = 0.0f;
}

#if 7
//******************************************************************************
// TODO:07 横方向に壁にあたっているかどうか
//------------------------------------------------------------------------------
/*
課題）
	(x, y)の位置から、上に height 分までの長さで、壁にめり込んでいるかどうか調べる
	pdfと縦方向の処理を参考に、考えて組みなさい。
*/
//******************************************************************************
#endif
bool BG::isWall(float x, float y, float height)
{
	//TODO_07
	for (; height > 0; height -= CHIP_SIZE) {
		const float top = y - height;
		if (top < 0 || top >= HEIGHT) continue;
		return isHitAll(x, y);   // 変更すること
	}
}

//右方向補正処理
void BG::mapHoseiRight(OBJ2D* obj)
{
	//TODO_08
	float x = obj->position.x + obj->size.x;
	x -= fmodf(x, (float)CHIP_SIZE);
	obj->position.x = x - obj->size.x - ADJUST_X;
	obj->speed.x = 0;
}

//左方向補正処理
void BG::mapHoseiLeft(OBJ2D* obj)
{
	//TODO_10
	float x = obj->position.x - obj->size.x;
	x += CHIP_SIZE - fmodf(x, (float)CHIP_SIZE);
	obj->position.x = x + obj->size.x + ADJUST_X;
	obj->speed.x = 0;
}


//はりに対する処理
bool BG::isNeedle(float x, float y, float width,float height)
{
	const float left = x - width;
	const float right = x + width;
	const float top = y - height + 3;
	const float bottom = y - 3;

	if (getTerrainAttr(left, top) == TR_ATTR::NEEDLE)  return true;
	if (getTerrainAttr(right, top) == TR_ATTR::NEEDLE) return true;
	if (getTerrainAttr(left,  bottom) == TR_ATTR::NEEDLE)  return true;
	if (getTerrainAttr(right, bottom) == TR_ATTR::NEEDLE) return true;

	return false;
}



